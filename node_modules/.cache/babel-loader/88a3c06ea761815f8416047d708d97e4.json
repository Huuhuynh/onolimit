{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nimport { remove, createElement, closest, formatUnit, Browser } from '@syncfusion/ej2-base';\nimport { isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { DataManager } from '@syncfusion/ej2-data';\nimport { dataReady, modelChanged, refreshVirtualBlock, contentReady } from '../base/constant';\nimport * as events from '../base/constant';\nimport { RenderType } from '../base/enum';\nimport { ContentRender } from './content-renderer';\nimport { HeaderRender } from './header-renderer';\nimport { InterSectionObserver } from '../services/intersection-observer';\nimport { VirtualRowModelGenerator } from '../services/virtual-row-model-generator';\nimport { isGroupAdaptive, getTransformValues } from '../base/util';\nimport { setStyleAttribute } from '@syncfusion/ej2-base';\n/**\n * VirtualContentRenderer\n * @hidden\n */\n\nvar VirtualContentRenderer =\n/** @class */\nfunction (_super) {\n  __extends(VirtualContentRenderer, _super);\n\n  function VirtualContentRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.prevHeight = 0;\n    _this.currentInfo = {};\n    _this.preventEvent = false;\n    _this.actions = ['filtering', 'searching', 'grouping', 'ungrouping'];\n    _this.offsets = {};\n    _this.tmpOffsets = {};\n    _this.virtualEle = new VirtualElementHandler();\n    _this.offsetKeys = [];\n    _this.isFocused = false;\n    _this.isSelection = false;\n    _this.isBottom = false;\n    _this.rndrCount = 0;\n    _this.locator = locator;\n\n    _this.eventListener('on');\n\n    _this.parent.on(events.columnVisibilityChanged, _this.setVisible, _this);\n\n    _this.vgenerator = _this.generator;\n    return _this;\n  }\n\n  VirtualContentRenderer.prototype.renderTable = function () {\n    this.header = this.locator.getService('rendererFactory').getRenderer(RenderType.Header);\n\n    _super.prototype.renderTable.call(this);\n\n    this.virtualEle.table = this.getTable();\n    this.virtualEle.content = this.content = this.getPanel().firstChild;\n    this.virtualEle.renderWrapper(this.parent.height);\n    this.virtualEle.renderPlaceHolder();\n\n    if (!this.parent.getFrozenColumns()) {\n      this.virtualEle.wrapper.style.position = 'absolute';\n    }\n\n    var debounceEvent = this.parent.dataSource instanceof DataManager && !this.parent.dataSource.dataSource.offline;\n    var content = this.parent.getFrozenColumns() ? this.parent.getMovableVirtualContent() : this.content;\n    var opt = {\n      container: content,\n      pageHeight: this.getBlockHeight() * 2,\n      debounceEvent: debounceEvent,\n      axes: this.parent.enableColumnVirtualization ? ['X', 'Y'] : ['Y']\n    };\n    this.observer = new InterSectionObserver(this.virtualEle.wrapper, opt);\n  };\n\n  VirtualContentRenderer.prototype.renderEmpty = function (tbody) {\n    this.getTable().appendChild(tbody);\n    this.virtualEle.adjustTable(0, 0);\n  };\n\n  VirtualContentRenderer.prototype.refreshMvTbalTransform = function () {\n    var mCont = this.parent.getMovableVirtualContent();\n    var fCont = this.parent.getFrozenVirtualContent();\n    var mContTV = getTransformValues(mCont.firstElementChild);\n    var fContTV = getTransformValues(fCont.firstElementChild);\n    var top = mCont.scrollTop;\n\n    if (top > 0 && mContTV.height !== fContTV.height) {\n      mCont.firstElementChild.style.transform = \"translate(\" + mContTV.width + \"px, \" + fContTV.height + \"px)\";\n    }\n  };\n\n  VirtualContentRenderer.prototype.scrollListener = function (scrollArgs) {\n    if (this.parent.enablePersistence) {\n      this.parent.scrollPosition = scrollArgs.offset;\n    }\n\n    if (this.preventEvent || this.parent.isDestroyed) {\n      this.preventEvent = false;\n      return;\n    }\n\n    if (isNullOrUndefined(document.activeElement)) {\n      this.isFocused = false;\n    } else {\n      this.isFocused = this.content === closest(document.activeElement, '.e-content') || this.content === document.activeElement;\n    }\n\n    if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && scrollArgs.sentinel.axis === 'X') {\n      this.refreshMvTbalTransform();\n    }\n\n    var info = scrollArgs.sentinel;\n    var viewInfo = this.currentInfo = this.getInfoFromView(scrollArgs.direction, info, scrollArgs.offset);\n\n    if (isGroupAdaptive(this.parent)) {\n      if (info.axis === 'Y' && this.prevInfo.blockIndexes.toString() === viewInfo.blockIndexes.toString() && scrollArgs.direction === 'up' && viewInfo.blockIndexes[viewInfo.blockIndexes.length - 1] !== 2) {\n        return;\n      } else {\n        viewInfo.event = 'refresh-virtual-block';\n\n        if (!isNullOrUndefined(viewInfo.offsets)) {\n          viewInfo.offsets.top = this.content.scrollTop;\n        }\n\n        this.parent.notify(viewInfo.event, {\n          requestType: 'virtualscroll',\n          virtualInfo: viewInfo,\n          focusElement: scrollArgs.focusElement\n        });\n        return;\n      }\n    }\n\n    if (this.prevInfo && (info.axis === 'Y' && this.prevInfo.blockIndexes.toString() === viewInfo.blockIndexes.toString() || info.axis === 'X' && this.prevInfo.columnIndexes.toString() === viewInfo.columnIndexes.toString())) {\n      if (Browser.isIE) {\n        this.parent.hideSpinner();\n      }\n\n      return;\n    }\n\n    this.parent.setColumnIndexesInView(this.parent.enableColumnVirtualization ? viewInfo.columnIndexes : []);\n    this.parent.pageSettings.currentPage = viewInfo.loadNext && !viewInfo.loadSelf ? viewInfo.nextInfo.page : viewInfo.page;\n\n    if (this.parent.getFrozenColumns() && this.parent.enableColumnVirtualization) {\n      var lastPage = Math.ceil(this.getTotalBlocks() / 2);\n\n      if (this.parent.pageSettings.currentPage === lastPage && scrollArgs.sentinel.axis === 'Y') {\n        this.rndrCount++;\n      }\n\n      if (scrollArgs.sentinel.axis === 'Y') {\n        if (this.parent.pageSettings.currentPage === lastPage && this.rndrCount > 1) {\n          this.rndrCount = 0;\n          return;\n        } else if (this.parent.pageSettings.currentPage !== lastPage && this.parent.pageSettings.currentPage !== lastPage - 1) {\n          this.rndrCount = 0;\n        }\n      }\n    }\n\n    this.parent.notify(viewInfo.event, {\n      requestType: 'virtualscroll',\n      virtualInfo: viewInfo,\n      focusElement: scrollArgs.focusElement\n    });\n  };\n\n  VirtualContentRenderer.prototype.block = function (blk) {\n    return this.vgenerator.isBlockAvailable(blk);\n  };\n\n  VirtualContentRenderer.prototype.getInfoFromView = function (direction, info, e) {\n    var tempBlocks = [];\n    var infoType = {\n      direction: direction,\n      sentinelInfo: info,\n      offsets: e\n    };\n    var vHeight = this.parent.height.toString().indexOf('%') < 0 ? this.content.getBoundingClientRect().height : this.parent.element.getBoundingClientRect().height;\n    infoType.page = this.getPageFromTop(e.top + vHeight, infoType);\n    infoType.blockIndexes = tempBlocks = this.vgenerator.getBlockIndexes(infoType.page);\n    infoType.loadSelf = !this.vgenerator.isBlockAvailable(tempBlocks[infoType.block]);\n    var blocks = this.ensureBlocks(infoType);\n    infoType.blockIndexes = blocks;\n    infoType.loadNext = !blocks.filter(function (val) {\n      return tempBlocks.indexOf(val) === -1;\n    }).every(this.block.bind(this));\n    infoType.event = infoType.loadNext || infoType.loadSelf ? modelChanged : refreshVirtualBlock;\n    infoType.nextInfo = infoType.loadNext ? {\n      page: Math.max(1, infoType.page + (direction === 'down' ? 1 : -1))\n    } : {};\n    infoType.columnIndexes = info.axis === 'X' ? this.vgenerator.getColumnIndexes() : this.parent.getColumnIndexesInView();\n\n    if (this.parent.enableColumnVirtualization && info.axis === 'X') {\n      infoType.event = refreshVirtualBlock;\n    }\n\n    return infoType;\n  };\n\n  VirtualContentRenderer.prototype.ensureBlocks = function (info) {\n    var _this = this;\n\n    var index = info.blockIndexes[info.block];\n    var mIdx;\n    var old = index;\n    var max = Math.max;\n    var indexes = info.direction === 'down' ? [max(index, 1), ++index, ++index] : [max(index - 1, 1), index, index + 1];\n\n    if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns()) {\n      if (info.sentinelInfo.axis === 'X' || info.sentinelInfo.axis === 'Y' && info.page === this.prevInfo.page) {\n        indexes = this.prevInfo.blockIndexes;\n      }\n    }\n\n    indexes = indexes.filter(function (val, ind) {\n      return indexes.indexOf(val) === ind;\n    });\n\n    if (this.prevInfo.blockIndexes.toString() === indexes.toString()) {\n      return indexes;\n    }\n\n    if (info.loadSelf || info.direction === 'down' && this.isEndBlock(old)) {\n      indexes = this.vgenerator.getBlockIndexes(info.page);\n    }\n\n    indexes.some(function (val, ind) {\n      var result = val === (isGroupAdaptive(_this.parent) ? _this.getGroupedTotalBlocks() : _this.getTotalBlocks());\n\n      if (result) {\n        mIdx = ind;\n      }\n\n      return result;\n    });\n\n    if (mIdx !== undefined) {\n      indexes = indexes.slice(0, mIdx + 1);\n\n      if (info.block === 0 && indexes.length === 1 && this.vgenerator.isBlockAvailable(indexes[0] - 1)) {\n        indexes = [indexes[0] - 1, indexes[0]];\n      }\n    }\n\n    return indexes;\n  };\n  /**\n   * @hidden\n   */\n\n\n  VirtualContentRenderer.prototype.vfTblTransform = function (info, left, top, e, cOffset, translate) {\n    var lastPage = Math.ceil(this.getTotalBlocks() / 2);\n    var isLastPage = lastPage === this.parent.pageSettings.currentPage && this.parent.enableColumnVirtualization;\n    var wrappers = [].slice.call(this.parent.getContent().querySelectorAll('.e-virtualtable'));\n\n    for (var i = 0; i < wrappers.length; i++) {\n      if (i === 0 && e.requestType === 'virtualscroll' && info.sentinelInfo.axis === 'X') {\n        continue;\n      }\n\n      if (lastPage !== this.parent.pageSettings.currentPage && this.parent.enableColumnVirtualization && (left > 0 || top > 0 && left === 0)) {\n        continue;\n      }\n\n      var cOff = isLastPage && i === 0 ? 0 : cOffset;\n      this.virtualEle.wrapper = wrappers[i];\n      this.virtualEle.adjustTable(cOff, translate);\n    }\n  };\n\n  VirtualContentRenderer.prototype.appendContent = function (target, newChild, e) {\n    // currentInfo value will be used if there are multiple dom updates happened due to mousewheel\n    var info = e.virtualInfo.sentinelInfo && e.virtualInfo.sentinelInfo.axis === 'Y' && this.currentInfo.page && this.currentInfo.page !== e.virtualInfo.page ? this.currentInfo : e.virtualInfo;\n    this.prevInfo = this.prevInfo || e.virtualInfo;\n    var cBlock = info.columnIndexes[0] - 1;\n    var cOffset = this.getColumnOffset(cBlock);\n    var width;\n    var blocks = info.blockIndexes;\n\n    if (this.parent.groupSettings.columns.length) {\n      this.refreshOffsets();\n    }\n\n    if (this.parent.height === '100%') {\n      this.parent.element.style.height = '100%';\n    }\n\n    var vHeight = this.parent.height.toString().indexOf('%') < 0 ? this.content.getBoundingClientRect().height : this.parent.element.getBoundingClientRect().height;\n    var translate = 0;\n\n    if (this.parent.getFrozenColumns()) {\n      var mCont = this.parent.getMovableVirtualContent();\n      var left = mCont.scrollLeft;\n      var top_1 = mCont.scrollTop;\n      translate = this.getTranslateY(mCont.scrollTop, vHeight, info);\n      this.vfTblTransform(info, left, top_1, e, cOffset, translate);\n    } else {\n      translate = this.getTranslateY(this.content.scrollTop, vHeight, info);\n      this.virtualEle.adjustTable(cOffset, translate);\n    }\n\n    if (this.parent.enableColumnVirtualization && !this.parent.getFrozenColumns()) {\n      this.header.virtualEle.adjustTable(cOffset, 0);\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      var cIndex = info.columnIndexes;\n      width = this.getColumnOffset(cIndex[cIndex.length - 1]) - this.getColumnOffset(cIndex[0] - 1) + '';\n      this.header.virtualEle.setWrapperWidth(width);\n    }\n\n    this.virtualEle.setWrapperWidth(width, Browser.isIE || Browser.info.name === 'edge');\n\n    if (!isNullOrUndefined(target.parentNode)) {\n      remove(target);\n    }\n\n    var tbody;\n\n    if (this.parent.getFrozenColumns() && !e.renderMovableContent) {\n      tbody = this.parent.getFrozenVirtualContent().querySelector('tbody');\n    } else if (this.parent.getFrozenColumns() && e.renderMovableContent) {\n      tbody = this.parent.getMovableVirtualContent().querySelector('tbody');\n    } else {\n      tbody = this.parent.element.querySelector('.e-content').querySelector('tbody');\n    }\n\n    if (tbody) {\n      remove(tbody);\n      target = null;\n    }\n\n    target = this.parent.createElement('tbody');\n    target.appendChild(newChild);\n\n    if (this.parent.frozenRows && e.requestType === 'virtualscroll' && this.parent.pageSettings.currentPage === 1) {\n      for (var i = 0; i < this.parent.frozenRows; i++) {\n        target.children[0].remove();\n      }\n    }\n\n    if (this.parent.getFrozenColumns()) {\n      if (!e.renderMovableContent) {\n        this.parent.getFrozenVirtualContent().querySelector('.e-table').appendChild(target);\n      } else {\n        this.parent.getMovableVirtualContent().querySelector('.e-table').appendChild(target);\n      }\n    } else {\n      this.getTable().appendChild(target);\n    }\n\n    if (this.parent.groupSettings.columns.length) {\n      if (!isGroupAdaptive(this.parent) && info.direction === 'up') {\n        var blk = this.offsets[this.getTotalBlocks()] - this.prevHeight;\n        this.preventEvent = true;\n        var sTop = this.content.scrollTop;\n        this.content.scrollTop = sTop + blk;\n      }\n\n      this.setVirtualHeight();\n      this.observer.setPageHeight(this.getOffset(blocks[blocks.length - 1]) - this.getOffset(blocks[0] - 1));\n    }\n\n    this.prevInfo = info;\n\n    if (this.isFocused) {\n      this.content.focus();\n    }\n\n    var lastPage = Math.ceil(this.getTotalBlocks() / 2);\n\n    if (this.isBottom) {\n      this.isBottom = false;\n      this.parent.getContent().firstElementChild.scrollTop = this.offsets[this.offsetKeys.length - 1];\n    }\n\n    if (this.parent.pageSettings.currentPage === lastPage && blocks.length === 1) {\n      this.isBottom = true;\n      this.parent.getContent().firstElementChild.scrollTop = this.offsets[this.offsetKeys.length - 2];\n    }\n\n    if (this.parent.enableColumnVirtualization && this.parent.getFrozenColumns() && e.requestType === 'virtualscroll' && e.virtualInfo.sentinelInfo.axis === 'X') {\n      this.refreshMvTbalTransform();\n    }\n  };\n\n  VirtualContentRenderer.prototype.onDataReady = function (e) {\n    if (!isNullOrUndefined(e.count)) {\n      this.count = e.count;\n      this.maxPage = Math.ceil(e.count / this.parent.pageSettings.pageSize);\n    }\n\n    this.vgenerator.checkAndResetCache(e.requestType);\n\n    if (['refresh', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder', undefined].some(function (value) {\n      return e.requestType === value;\n    })) {\n      this.refreshOffsets();\n    }\n\n    if (this.parent.getFrozenColumns() && this.parent.enableColumnVirtualization) {\n      var hdrTbls = [].slice.call(this.parent.getHeaderContent().querySelectorAll('.e-table'));\n      this.header.virtualEle.table = hdrTbls[1];\n    }\n\n    this.setVirtualHeight();\n    this.resetScrollPosition(e.requestType);\n  };\n\n  VirtualContentRenderer.prototype.setVirtualHeight = function () {\n    var width = this.parent.enableColumnVirtualization ? this.getColumnOffset(this.parent.columns.length + this.parent.groupSettings.columns.length - 1) + 'px' : '100%';\n\n    if (this.parent.getFrozenColumns()) {\n      var fTblWidth = this.parent.enableColumnVirtualization ? 'auto' : width;\n      this.virtualEle.placeholder = this.parent.getFrozenVirtualContent().querySelector('.e-virtualtrack'); // To overcome the white space issue in last page (instead of position absolute)\n\n      this.virtualEle.setVirtualHeight(this.offsets[this.getTotalBlocks() - 2], fTblWidth);\n      this.virtualEle.placeholder = this.parent.getMovableVirtualContent().querySelector('.e-virtualtrack'); // To overcome the white space issue in last page (instead of position absolute)\n\n      this.virtualEle.setVirtualHeight(this.offsets[this.getTotalBlocks() - 2], width);\n    } else {\n      this.virtualEle.setVirtualHeight(this.offsets[isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks()], width);\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      this.header.virtualEle.setVirtualHeight(1, width);\n    }\n  };\n\n  VirtualContentRenderer.prototype.getPageFromTop = function (sTop, info) {\n    var _this = this;\n\n    var total = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n    var page = 0;\n    var extra = this.offsets[total] - this.prevHeight;\n    this.offsetKeys.some(function (offset) {\n      var iOffset = Number(offset);\n      var border = sTop <= _this.offsets[offset] || iOffset === total && sTop > _this.offsets[offset];\n\n      if (border) {\n        info.block = iOffset % 2 === 0 ? 1 : 0;\n        page = Math.max(1, Math.min(_this.vgenerator.getPage(iOffset), _this.maxPage));\n      }\n\n      return border;\n    });\n    return page;\n  };\n\n  VirtualContentRenderer.prototype.getTranslateY = function (sTop, cHeight, info, isOnenter) {\n    if (info === undefined) {\n      info = {\n        page: this.getPageFromTop(sTop + cHeight, {})\n      };\n      info.blockIndexes = this.vgenerator.getBlockIndexes(info.page);\n    }\n\n    var block = (info.blockIndexes[0] || 1) - 1;\n    var translate = this.getOffset(block);\n    var endTranslate = this.getOffset(info.blockIndexes[info.blockIndexes.length - 1]);\n\n    if (isOnenter) {\n      info = this.prevInfo;\n    }\n\n    var result = translate > sTop ? this.getOffset(block - 1) : endTranslate < sTop + cHeight ? this.getOffset(block + 1) : translate;\n    var blockHeight = this.offsets[info.blockIndexes[info.blockIndexes.length - 1]] - this.tmpOffsets[info.blockIndexes[0]];\n\n    if (result + blockHeight > this.offsets[isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks()]) {\n      result -= result + blockHeight - this.offsets[this.getTotalBlocks()];\n    }\n\n    return result;\n  };\n\n  VirtualContentRenderer.prototype.getOffset = function (block) {\n    return Math.min(this.offsets[block] | 0, this.offsets[this.maxBlock] | 0);\n  };\n\n  VirtualContentRenderer.prototype.onEntered = function () {\n    var _this = this;\n\n    return function (element, current, direction, e, isWheel, check) {\n      if (Browser.isIE && !isWheel && check && !_this.preventEvent) {\n        _this.parent.showSpinner();\n      }\n\n      var xAxis = current.axis === 'X';\n      var top = _this.prevInfo.offsets ? _this.prevInfo.offsets.top : null;\n\n      var height = _this.content.getBoundingClientRect().height;\n\n      var x = _this.getColumnOffset(xAxis ? _this.vgenerator.getColumnIndexes()[0] - 1 : _this.prevInfo.columnIndexes[0] - 1);\n\n      var y = _this.getTranslateY(e.top, height, xAxis && top === e.top ? _this.prevInfo : undefined, true);\n\n      _this.virtualEle.adjustTable(x, Math.min(y, _this.offsets[_this.maxBlock]));\n\n      if (_this.parent.getFrozenColumns() && !xAxis) {\n        var left = _this.parent.getMovableVirtualContent().scrollLeft;\n\n        if (_this.parent.enableColumnVirtualization && left > 0) {\n          var fvTable = _this.parent.getFrozenVirtualContent().querySelector('.e-virtualtable');\n\n          fvTable.style.transform = \"translate(\" + 0 + \"px, \" + Math.min(y, _this.offsets[_this.maxBlock]) + \"px)\";\n        } else {\n          var fvTable = _this.parent.getFrozenVirtualContent().querySelector('.e-virtualtable');\n\n          fvTable.style.transform = \"translate(\" + x + \"px, \" + Math.min(y, _this.offsets[_this.maxBlock]) + \"px)\";\n        }\n      }\n\n      if (_this.parent.enableColumnVirtualization) {\n        _this.header.virtualEle.adjustTable(x, 0);\n      }\n    };\n  };\n\n  VirtualContentRenderer.prototype.dataBound = function () {\n    if (this.isSelection) {\n      this.isSelection = false;\n      this.parent.selectRow(this.selectedRowIndex);\n    }\n  };\n\n  VirtualContentRenderer.prototype.eventListener = function (action) {\n    var _this = this;\n\n    this.parent[action](dataReady, this.onDataReady, this);\n    this.parent.addEventListener(events.dataBound, this.dataBound.bind(this));\n    this.parent[action](refreshVirtualBlock, this.refreshContentRows, this);\n    this.parent[action](events.selectVirtualRow, this.selectVirtualRow, this);\n    this.actions.forEach(function (event) {\n      return _this.parent[action](event + \"-begin\", _this.onActionBegin, _this);\n    });\n\n    var fn = function () {\n      _this.observer.observe(function (scrollArgs) {\n        return _this.scrollListener(scrollArgs);\n      }, _this.onEntered());\n\n      var gObj = _this.parent;\n\n      if (gObj.enablePersistence && gObj.scrollPosition) {\n        _this.content.scrollTop = gObj.scrollPosition.top;\n        var scrollValues = {\n          direction: 'down',\n          sentinel: _this.observer.sentinelInfo.down,\n          offset: gObj.scrollPosition,\n          focusElement: gObj.element\n        };\n\n        _this.scrollListener(scrollValues);\n\n        if (gObj.enableColumnVirtualization) {\n          _this.content.scrollLeft = gObj.scrollPosition.left;\n        }\n      }\n\n      _this.parent.off(contentReady, fn);\n    };\n\n    this.parent.on(contentReady, fn, this);\n  };\n\n  VirtualContentRenderer.prototype.getBlockSize = function () {\n    return this.parent.pageSettings.pageSize >> 1;\n  };\n\n  VirtualContentRenderer.prototype.getBlockHeight = function () {\n    return this.getBlockSize() * this.parent.getRowHeight();\n  };\n\n  VirtualContentRenderer.prototype.isEndBlock = function (index) {\n    var totalBlocks = this.getTotalBlocks();\n    return index >= totalBlocks || index === totalBlocks - 1;\n  };\n\n  VirtualContentRenderer.prototype.getGroupedTotalBlocks = function () {\n    var rows = this.parent.vcRows;\n    return Math.floor(rows.length / this.getBlockSize() < 1 ? 1 : rows.length / this.getBlockSize());\n  };\n\n  VirtualContentRenderer.prototype.getTotalBlocks = function () {\n    return Math.ceil(this.count / this.getBlockSize());\n  };\n\n  VirtualContentRenderer.prototype.getColumnOffset = function (block) {\n    return this.vgenerator.cOffsets[block] | 0;\n  };\n\n  VirtualContentRenderer.prototype.getModelGenerator = function () {\n    return new VirtualRowModelGenerator(this.parent);\n  };\n\n  VirtualContentRenderer.prototype.resetScrollPosition = function (action) {\n    if (this.actions.some(function (value) {\n      return value === action;\n    })) {\n      this.preventEvent = this.content.scrollTop !== 0;\n      this.content.scrollTop = 0;\n    }\n  };\n\n  VirtualContentRenderer.prototype.onActionBegin = function (e) {\n    //Update property silently..\n    this.parent.setProperties({\n      pageSettings: {\n        currentPage: 1\n      }\n    }, true);\n  };\n\n  VirtualContentRenderer.prototype.getRows = function () {\n    return this.vgenerator.getRows();\n  };\n\n  VirtualContentRenderer.prototype.getRowByIndex = function (index) {\n    if (isGroupAdaptive(this.parent)) {\n      return this.parent.getDataRows()[index];\n    }\n\n    return this.getRowCollection(index, false);\n  };\n\n  VirtualContentRenderer.prototype.getMovableVirtualRowByIndex = function (index) {\n    return this.getRowCollection(index, true);\n  };\n\n  VirtualContentRenderer.prototype.getRowCollection = function (index, isMovable) {\n    var prev = this.prevInfo.blockIndexes;\n    var startIdx = (prev[0] - 1) * this.getBlockSize();\n    var rowCollection = isMovable ? this.parent.getMovableDataRows() : this.parent.getDataRows();\n    var selectedRow = rowCollection[index - startIdx];\n\n    if (this.parent.frozenRows && this.parent.pageSettings.currentPage > 1) {\n      selectedRow = index <= this.parent.frozenRows ? rowCollection[index] : rowCollection[index - startIdx + this.parent.frozenRows];\n    }\n\n    return selectedRow;\n  };\n\n  VirtualContentRenderer.prototype.getVirtualRowIndex = function (index) {\n    var prev = this.prevInfo.blockIndexes;\n    var startIdx = (prev[0] - 1) * this.getBlockSize();\n    return startIdx + index;\n  };\n\n  VirtualContentRenderer.prototype.refreshOffsets = function () {\n    var _this = this;\n\n    var gObj = this.parent;\n    var row = 0;\n    var bSize = this.getBlockSize();\n    var total = isGroupAdaptive(this.parent) ? this.getGroupedTotalBlocks() : this.getTotalBlocks();\n    this.prevHeight = this.offsets[total];\n    this.maxBlock = total % 2 === 0 ? total - 2 : total - 1;\n    this.offsets = {}; //Row offset update\n\n    Array.apply(null, Array(total)).map(function () {\n      return ++row;\n    }).forEach(function (block) {\n      var tmp = (_this.vgenerator.cache[block] || []).length;\n      var rem = !isGroupAdaptive(_this.parent) ? _this.count % bSize : gObj.vcRows.length % bSize;\n      var size = !isGroupAdaptive(_this.parent) && block in _this.vgenerator.cache ? tmp * _this.parent.getRowHeight() : rem && block === total ? rem * _this.parent.getRowHeight() : _this.getBlockHeight(); // let size: number = this.parent.groupSettings.columns.length && block in this.vgenerator.cache ?\n      // tmp * getRowHeight() : this.getBlockHeight();\n\n      _this.offsets[block] = (_this.offsets[block - 1] | 0) + size;\n      _this.tmpOffsets[block] = _this.offsets[block - 1] | 0;\n    });\n    this.offsetKeys = Object.keys(this.offsets);\n\n    if (isGroupAdaptive(this.parent)) {\n      this.parent.vGroupOffsets = this.offsets;\n    } //Column offset update\n\n\n    if (this.parent.enableColumnVirtualization) {\n      this.vgenerator.refreshColOffsets();\n    }\n  };\n\n  VirtualContentRenderer.prototype.refreshVirtualElement = function () {\n    this.vgenerator.refreshColOffsets();\n    this.setVirtualHeight();\n  };\n\n  VirtualContentRenderer.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n    var rows = [];\n    rows = this.getRows();\n    var testRow;\n    rows.some(function (r) {\n      if (r.isDataRow) {\n        testRow = r;\n      }\n\n      return r.isDataRow;\n    });\n    var needFullRefresh = true;\n\n    if (!gObj.groupSettings.columns.length && testRow) {\n      needFullRefresh = false;\n    }\n\n    var tr = gObj.getDataRows();\n\n    for (var c = 0, clen = columns.length; c < clen; c++) {\n      var column = columns[c];\n      var idx = gObj.getNormalizedColumnIndex(column.uid);\n      var displayVal = column.visible === true ? '' : 'none';\n\n      if (idx !== -1 && testRow && idx < testRow.cells.length) {\n        setStyleAttribute(this.getColGroup().childNodes[idx], {\n          'display': displayVal\n        });\n      }\n\n      if (!needFullRefresh) {\n        var width = void 0;\n\n        if (column.visible) {\n          width = this.virtualEle.wrapper.offsetWidth + parseInt(column.width.toString(), 10);\n        } else {\n          width = this.virtualEle.wrapper.offsetWidth - parseInt(column.width.toString(), 10);\n        }\n\n        if (width > gObj.width) {\n          this.setDisplayNone(tr, idx, displayVal, rows);\n          this.virtualEle.setWrapperWidth(width + '');\n          this.vgenerator.refreshColOffsets();\n          this.refreshVirtualElement();\n        } else {\n          this.refreshContentRows({\n            requestType: 'refresh'\n          });\n        }\n      }\n\n      if (!this.parent.invokedFromMedia && column.hideAtMedia) {\n        this.parent.updateMediaColumns(column);\n      }\n\n      this.parent.invokedFromMedia = false;\n    }\n\n    if (needFullRefresh) {\n      this.refreshContentRows({\n        requestType: 'refresh'\n      });\n    } else {\n      this.parent.notify(events.partialRefresh, {\n        rows: rows,\n        args: {\n          isFrozen: false,\n          rows: rows\n        }\n      });\n    }\n  };\n\n  VirtualContentRenderer.prototype.selectVirtualRow = function (args) {\n    this.isSelection = true;\n    this.selectedRowIndex = args.selectedIndex;\n    var page = Math.ceil((args.selectedIndex + 1) / this.parent.pageSettings.pageSize);\n    var blockIndexes = this.vgenerator.getBlockIndexes(page);\n    var scrollTop = this.offsets[blockIndexes[0] - 1];\n    var ele = this.parent.getFrozenColumns() ? this.parent.getMovableVirtualContent() : this.parent.getContent().firstElementChild;\n    ele.scrollTop = scrollTop;\n  };\n\n  return VirtualContentRenderer;\n}(ContentRender);\n\nexport { VirtualContentRenderer };\n/**\n * @hidden\n */\n\nvar VirtualHeaderRenderer =\n/** @class */\nfunction (_super) {\n  __extends(VirtualHeaderRenderer, _super);\n\n  function VirtualHeaderRenderer(parent, locator) {\n    var _this = _super.call(this, parent, locator) || this;\n\n    _this.virtualEle = new VirtualElementHandler();\n    _this.gen = new VirtualRowModelGenerator(_this.parent);\n\n    _this.parent.on(events.columnVisibilityChanged, _this.setVisible, _this);\n\n    _this.parent.on(refreshVirtualBlock, function (e) {\n      return e.virtualInfo.sentinelInfo.axis === 'X' ? _this.refreshUI() : null;\n    }, _this);\n\n    return _this;\n  }\n\n  VirtualHeaderRenderer.prototype.renderTable = function () {\n    this.gen.refreshColOffsets();\n    this.parent.setColumnIndexesInView(this.gen.getColumnIndexes(this.getPanel().firstChild));\n\n    _super.prototype.renderTable.call(this);\n\n    this.virtualEle.table = this.getTable();\n    this.virtualEle.content = this.getPanel().firstChild;\n    this.virtualEle.content.style.position = 'relative';\n    this.virtualEle.renderWrapper();\n    this.virtualEle.renderPlaceHolder('absolute');\n  };\n\n  VirtualHeaderRenderer.prototype.appendContent = function (table) {\n    this.virtualEle.wrapper.appendChild(table);\n  };\n\n  VirtualHeaderRenderer.prototype.refreshUI = function () {\n    if (this.parent.getFrozenColumns() && this.parent.enableColumnVirtualization) {\n      this.parent.contentModule.setTable(this.parent.getMovableVirtualContent().querySelector('.e-table'));\n    }\n\n    this.gen.refreshColOffsets();\n    this.parent.setColumnIndexesInView(this.gen.getColumnIndexes(this.getPanel().firstChild));\n\n    _super.prototype.refreshUI.call(this);\n\n    if (this.parent.getFrozenColumns() && this.parent.enableColumnVirtualization) {\n      this.parent.contentModule.setTable(this.parent.getFrozenVirtualContent().querySelector('.e-table'));\n    }\n  };\n\n  VirtualHeaderRenderer.prototype.setVisible = function (columns) {\n    var gObj = this.parent;\n    var displayVal;\n    var idx;\n\n    for (var c = 0, clen = columns.length; c < clen; c++) {\n      var column = columns[c];\n      idx = gObj.getNormalizedColumnIndex(column.uid);\n      displayVal = column.visible ? '' : 'none';\n      setStyleAttribute(this.getColGroup().children[idx], {\n        'display': displayVal\n      });\n\n      if (gObj.enableColumnVirtualization && !gObj.groupSettings.columns.length) {\n        var tablewidth = void 0;\n\n        if (column.visible) {\n          tablewidth = this.virtualEle.wrapper.offsetWidth + parseInt(column.width.toString(), 10);\n        } else {\n          tablewidth = this.virtualEle.wrapper.offsetWidth - parseInt(column.width.toString(), 10);\n        }\n\n        if (tablewidth > gObj.width) {\n          this.setDisplayNone(column, displayVal);\n          this.virtualEle.setWrapperWidth(tablewidth + '');\n          this.gen.refreshColOffsets();\n        } else {\n          this.refreshUI();\n        }\n      } else {\n        this.refreshUI();\n      }\n    }\n  };\n\n  VirtualHeaderRenderer.prototype.setDisplayNone = function (col, displayVal) {\n    for (var _i = 0, _a = [].slice.apply(this.getTable().querySelectorAll('th.e-headercell')); _i < _a.length; _i++) {\n      var ele = _a[_i];\n\n      if (ele.querySelector('[e-mappinguid]') && ele.querySelector('[e-mappinguid]').getAttribute('e-mappinguid') === col.uid) {\n        setStyleAttribute(ele, {\n          'display': displayVal\n        });\n        break;\n      }\n    }\n  };\n\n  return VirtualHeaderRenderer;\n}(HeaderRender);\n\nexport { VirtualHeaderRenderer };\n/**\n * @hidden\n */\n\nvar VirtualElementHandler =\n/** @class */\nfunction () {\n  function VirtualElementHandler() {}\n\n  VirtualElementHandler.prototype.renderWrapper = function (height) {\n    this.wrapper = createElement('div', {\n      className: 'e-virtualtable',\n      styles: \"min-height:\" + formatUnit(height)\n    });\n    this.wrapper.appendChild(this.table);\n    this.content.appendChild(this.wrapper);\n  };\n\n  VirtualElementHandler.prototype.renderPlaceHolder = function (position) {\n    if (position === void 0) {\n      position = 'relative';\n    }\n\n    this.placeholder = createElement('div', {\n      className: 'e-virtualtrack',\n      styles: \"position:\" + position\n    });\n    this.content.appendChild(this.placeholder);\n  };\n\n  VirtualElementHandler.prototype.adjustTable = function (xValue, yValue) {\n    this.wrapper.style.transform = \"translate(\" + xValue + \"px, \" + yValue + \"px)\";\n  };\n\n  VirtualElementHandler.prototype.setWrapperWidth = function (width, full) {\n    this.wrapper.style.width = width ? width + \"px\" : full ? '100%' : '';\n  };\n\n  VirtualElementHandler.prototype.setVirtualHeight = function (height, width) {\n    this.placeholder.style.height = height + \"px\";\n    this.placeholder.style.width = width;\n  };\n\n  return VirtualElementHandler;\n}();\n\nexport { VirtualElementHandler };","map":null,"metadata":{},"sourceType":"module"}