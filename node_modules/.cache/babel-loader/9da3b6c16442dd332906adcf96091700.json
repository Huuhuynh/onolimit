{"ast":null,"code":"import { Browser } from '@syncfusion/ej2-base';\nimport { isGroupAdaptive } from '../base/util';\nimport { RowModelGenerator } from '../services/row-model-generator';\nimport { GroupModelGenerator } from '../services/group-model-generator';\n/**\n * Content module is used to render grid content\n */\n\nvar VirtualRowModelGenerator =\n/** @class */\nfunction () {\n  function VirtualRowModelGenerator(parent) {\n    this.cOffsets = {};\n    this.cache = {};\n    this.data = {};\n    this.groups = {};\n    this.parent = parent;\n    this.model = this.parent.pageSettings;\n    this.rowModelGenerator = this.parent.allowGrouping ? new GroupModelGenerator(this.parent) : new RowModelGenerator(this.parent);\n  }\n\n  VirtualRowModelGenerator.prototype.generateRows = function (data, notifyArgs) {\n    var _this = this;\n\n    var info = notifyArgs.virtualInfo = notifyArgs.virtualInfo || this.getData();\n    var xAxis = info.sentinelInfo && info.sentinelInfo.axis === 'X';\n    var page = !xAxis && info.loadNext && !info.loadSelf ? info.nextInfo.page : info.page;\n    var result = [];\n    var center = ~~(this.model.pageSize / 2);\n    var indexes = this.getBlockIndexes(page);\n    var loadedBlocks = [];\n    this.checkAndResetCache(notifyArgs.requestType);\n\n    if (isGroupAdaptive(this.parent) && this.parent.vcRows.length) {\n      return result = this.parent.vcRows;\n    }\n\n    if (this.parent.enableColumnVirtualization) {\n      info.blockIndexes.forEach(function (value) {\n        if (_this.isBlockAvailable(value)) {\n          _this.cache[value] = _this.rowModelGenerator.refreshRows(_this.cache[value]);\n        }\n      });\n    }\n\n    info.blockIndexes.forEach(function (value) {\n      if (!_this.isBlockAvailable(value)) {\n        var rows = _this.rowModelGenerator.generateRows(data, {\n          virtualInfo: info,\n          startIndex: _this.getStartIndex(value, data)\n        });\n\n        if (isGroupAdaptive(_this.parent) && !_this.parent.vcRows.length) {\n          _this.parent.vRows = rows;\n          _this.parent.vcRows = rows;\n        }\n\n        var median = void 0;\n\n        if (isGroupAdaptive(_this.parent)) {\n          median = _this.model.pageSize / 2;\n\n          if (!_this.isBlockAvailable(indexes[0])) {\n            _this.cache[indexes[0]] = rows.slice(0, median);\n          }\n\n          if (!_this.isBlockAvailable(indexes[1])) {\n            _this.cache[indexes[1]] = rows.slice(median, _this.model.pageSize);\n          }\n        } else {\n          median = ~~Math.max(rows.length, _this.model.pageSize) / 2;\n\n          if (!_this.isBlockAvailable(indexes[0])) {\n            _this.cache[indexes[0]] = rows.slice(0, median);\n          }\n\n          if (!_this.isBlockAvailable(indexes[1])) {\n            _this.cache[indexes[1]] = rows.slice(median);\n          }\n        }\n      }\n\n      if (_this.parent.groupSettings.columns.length && !xAxis && _this.cache[value]) {\n        _this.cache[value] = _this.updateGroupRow(_this.cache[value], value);\n      }\n\n      result.push.apply(result, _this.cache[value]);\n\n      if (_this.isBlockAvailable(value)) {\n        loadedBlocks.push(value);\n      }\n    });\n    info.blockIndexes = loadedBlocks;\n    var grouping = 'records';\n\n    if (this.parent.allowGrouping) {\n      this.parent.currentViewData[grouping] = result.map(function (m) {\n        return m.data;\n      });\n    } else {\n      this.parent.currentViewData = result.map(function (m) {\n        return m.data;\n      });\n    }\n\n    return result;\n  };\n\n  VirtualRowModelGenerator.prototype.getBlockIndexes = function (page) {\n    return [page + (page - 1), page * 2];\n  };\n\n  VirtualRowModelGenerator.prototype.getPage = function (block) {\n    return block % 2 === 0 ? block / 2 : (block + 1) / 2;\n  };\n\n  VirtualRowModelGenerator.prototype.isBlockAvailable = function (value) {\n    return value in this.cache;\n  };\n\n  VirtualRowModelGenerator.prototype.getData = function () {\n    return {\n      page: this.model.currentPage,\n      blockIndexes: this.getBlockIndexes(this.model.currentPage),\n      direction: 'down',\n      columnIndexes: this.parent.getColumnIndexesInView()\n    };\n  };\n\n  VirtualRowModelGenerator.prototype.getStartIndex = function (blk, data, full) {\n    if (full === void 0) {\n      full = true;\n    }\n\n    var page = this.getPage(blk);\n    var even = blk % 2 === 0;\n    var index = (page - 1) * this.model.pageSize;\n    return full || !even ? index : index + ~~(this.model.pageSize / 2);\n  };\n\n  VirtualRowModelGenerator.prototype.getColumnIndexes = function (content) {\n    var _this = this;\n\n    if (content === void 0) {\n      content = this.parent.getHeaderContent().firstChild;\n    }\n\n    if (this.parent.getFrozenColumns()) {\n      content = content.querySelector('.e-movableheader');\n    }\n\n    var indexes = [];\n    var sLeft = content.scrollLeft | 0;\n    var keys = Object.keys(this.cOffsets);\n    var cWidth = content.getBoundingClientRect().width;\n    sLeft = Math.min(this.cOffsets[keys.length - 1] - cWidth, sLeft);\n    var calWidth = Browser.isDevice ? 2 * cWidth : cWidth / 2;\n    var left = sLeft + cWidth + (sLeft === 0 ? calWidth : 0);\n    keys.some(function (offset, indx, input) {\n      var iOffset = Number(offset);\n      var offsetVal = _this.cOffsets[offset];\n      var border = sLeft - calWidth <= offsetVal && left + calWidth >= offsetVal;\n\n      if (border) {\n        indexes.push(iOffset);\n      }\n\n      return left + calWidth < offsetVal;\n    });\n    return indexes;\n  };\n\n  VirtualRowModelGenerator.prototype.checkAndResetCache = function (action) {\n    var clear = ['paging', 'refresh', 'sorting', 'filtering', 'searching', 'grouping', 'ungrouping', 'reorder', 'save', 'delete'].some(function (value) {\n      return action === value;\n    });\n\n    if (clear) {\n      this.cache = {};\n      this.data = {};\n      this.groups = {};\n    }\n\n    return clear;\n  };\n\n  VirtualRowModelGenerator.prototype.refreshColOffsets = function () {\n    var _this = this;\n\n    var col = 0;\n    this.cOffsets = {};\n    var gLen = this.parent.groupSettings.columns.length;\n    var cols = this.parent.columns;\n    var cLen = cols.length;\n\n    var isVisible = function (column) {\n      return column.visible && (!_this.parent.groupSettings.showGroupedColumn ? _this.parent.groupSettings.columns.indexOf(column.field) < 0 : column.visible);\n    };\n\n    this.parent.groupSettings.columns.forEach(function (c, n) {\n      return _this.cOffsets[n] = (_this.cOffsets[n - 1] | 0) + 30;\n    });\n    Array.apply(null, Array(cLen)).map(function () {\n      return col++;\n    }).forEach(function (block, i) {\n      block = block + gLen;\n      _this.cOffsets[block] = (_this.cOffsets[block - 1] | 0) + (isVisible(cols[i]) ? parseInt(cols[i].width, 10) : 0);\n    });\n  };\n\n  VirtualRowModelGenerator.prototype.updateGroupRow = function (current, block) {\n    var _this = this;\n\n    var currentFirst = current[0];\n    var rows = [];\n    Object.keys(this.cache).forEach(function (key) {\n      if (Number(key) < block) {\n        rows = rows.concat(_this.cache[key]);\n      }\n    });\n\n    if (currentFirst && currentFirst.isDataRow || block % 2 === 0) {\n      return current;\n    }\n\n    return this.iterateGroup(current, rows);\n  };\n\n  VirtualRowModelGenerator.prototype.iterateGroup = function (current, rows) {\n    var currentFirst = current[0];\n    var offset = 0;\n\n    if (currentFirst && currentFirst.isDataRow) {\n      return current;\n    }\n\n    var isPresent = current.some(function (row) {\n      return rows.some(function (oRow, index) {\n        var res = oRow && oRow.data.field !== undefined && oRow.data.field === row.data.field && oRow.data.key === row.data.key;\n\n        if (res) {\n          offset = index;\n        }\n\n        return res;\n      });\n    });\n\n    if (isPresent) {\n      current.shift();\n      current = this.iterateGroup(current, rows.slice(offset));\n    }\n\n    return current;\n  };\n\n  VirtualRowModelGenerator.prototype.getRows = function () {\n    var _this = this;\n\n    var rows = [];\n    Object.keys(this.cache).forEach(function (key) {\n      return rows = rows.concat(_this.cache[key]);\n    });\n    return rows;\n  };\n\n  return VirtualRowModelGenerator;\n}();\n\nexport { VirtualRowModelGenerator };","map":null,"metadata":{},"sourceType":"module"}